// ========================================================================= //
// Copyright (c) 2003-2007, John Harrison.                                   //
// Copyright (c) 2012 Eric Taucher, Jack Pappas, Anh-Dung Phan               //
// Copyright (c) 2023 Domenico Masini (derived from lib.fs)
// (See "LICENSE.txt" for details.)                                          //
// ========================================================================= //

/// Functions to handle searching
[<AutoOpen>]
module FolAutomReas.Lib.Search

/// Returns the result of the first successful application of a function to the 
/// elements of a list.
/// 
/// tryfind f [x1;...;xn] returns (f xi) for the first xi in the list for which 
/// application of f succeeds.
/// 
/// Fails with tryfind if the application of the function fails for all 
/// elements in the list. This will always be the case if the list is empty.
let rec tryfind f l =
    match l with
    | [] ->
        failwith "tryfind"
    | h :: t ->
        try f h
        with Failure _ ->
            tryfind f t
        
/// Applies a function to every element of a list, returning a list of results 
/// for those elements for which application succeeds.
/// 
/// mapfilter last [[1;2;3];[4;5];[];[6;7;8];[]] returns [3;5;8]
/// 
/// Fails if an exception not of the form Failure _ is generated by any 
/// application to the elements.
let rec mapfilter f l =
    match l with
    | [] -> []
    | h :: t ->
        let rest = mapfilter f t
        try (f h) :: rest
        with Failure _ -> rest

// ------------------------------------------------------------------------- //
// Find list member that maximizes or minimizes a function.                  //
// ------------------------------------------------------------------------- //

/// finds the element of a list l that maximizes or minimizes a function f 
/// based on the given ord.
/// 
/// Support function for use with maximize and minimize.
let optimize ord f lst =
    lst
    |> List.map (fun x -> x, f x)
    |> List.reduceBack (fun (_, y1 as p1) (_, y2 as p2) ->
        if ord y1 y2 then p1 else p2)
    |> fst
                        
/// finds the element of a list l that maximizes a function f
/// 
/// maximize ((*) -1) [-1;2;3] returns -1
let maximize f l =
    optimize (>) f l
    
/// finds the element of a list l that minimizes a function f
/// 
/// minimize ((*) -1) [-1;2;3] returns 3
let minimize f l =
    optimize (<) f l